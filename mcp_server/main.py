# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T04:12:16+00:00



import argparse
import json
import os
from typing import *
from typing import Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path

from models import (
    CreateOrderRequest,
    CustomerTokenCreationRequest,
    CustomerTokenCreationResponse,
    ErrorV2,
    MerchantSession,
    Order,
    Session,
    SessionCreate,
    SessionRead,
)

app = MCPProxy(
    description="The payments API is used to create a session to offer Klarna's payment methods as part of your checkout. As soon as the purchase is completed the order should be read and handled using the [`Order Management API`](https://docs.klarna.com/api/ordermanagement).\n\nRead more on [Klarna payments](https://docs.klarna.com/klarna-payments/).",
    title='Klarna Payments API V1',
    version='1.0.0',
    servers=[{'url': 'https://api.klarna.com'}],
)


@app.delete(
    '/payments/v1/authorizations/{authorizationToken}',
    description=""" Use this API call to cancel/release an authorization. If the `authorization_token` received during a Klarna Payments won’t be used to place an order immediately you could release the authorization.
Read more on **[Cancel an existing authorization](https://docs.klarna.com/klarna-payments/other-actions/cancel-an-authorization/)**. """,
    tags=['authorization_management'],
)
def cancel_authorization(
    authorization_token: str = Path(..., alias='authorizationToken')
):
    """
    Cancel an existing authorization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payments/v1/authorizations/{authorizationToken}/customer-token',
    description=""" Use this API call to create a Klarna Customer Token.<br/>After having obtained an `authorization_token` for a successful authorization, this can be used to create a purchase token instead of placing the order. Creating a Klarna Customer Token results in Klarna storing customer and payment method details.
Read more on **[Generate a consumer token](https://docs.klarna.com/klarna-payments/in-depth-knowledge/customer-token/)**. """,
    tags=['authorization_management'],
)
def purchase_token(
    authorization_token: str = Path(..., alias='authorizationToken'),
    body: CustomerTokenCreationRequest = None,
):
    """
    Generate a consumer token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payments/v1/authorizations/{authorizationToken}/order',
    description=""" Use this API call to create a new order. Placing an order towards Klarna means that the Klarna Payments session will be closed and that an order will be created in Klarna's system.<br/>When you have received the `authorization_token` for a successful authorization you can place the order. Among the other order details in this request, you include a URL to the confirmation page for the customer.<br/>When the Order has been successfully placed at Klarna, you need to handle it either through the Merchant Portal or using [Klarna’s Order Management API](#order-management-api).
Read more on **[Create a new order](https://docs.klarna.com/klarna-payments/integrate-with-klarna-payments/step-3-create-an-order/)**. """,
    tags=['order_creation'],
)
def create_order(
    authorization_token: str = Path(..., alias='authorizationToken'),
    body: CreateOrderRequest = None,
):
    """
    Create a new order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payments/v1/sessions',
    description=""" Use this API call to create a Klarna Payments session.<br/>When a session is created you will receive the available `payment_method_categories` for the session, a `session_id` and a `client_token`. The `session_id` can be used to read or update the session using the REST API. The `client_token` should be passed to the browser.
Read more on **[Create a new payment session](https://docs.klarna.com/klarna-payments/integrate-with-klarna-payments/step-1-initiate-a-payment/)**. """,
    tags=['payment_session_operations'],
)
def create_credit_session(body: SessionCreate):
    """
    Create a new payment session
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/payments/v1/sessions/{session_id}',
    description=""" Use this API call to read a Klarna Payments session. You can read the Klarna Payments session at any time after it has been created, to get information about it. This will return all data that has been collected during the session.
Read more on **[Read an existing payment session](https://docs.klarna.com/klarna-payments/other-actions/check-the-details-of-a-payment-session/)**. """,
    tags=['payment_session_operations'],
)
def read_credit_session(session_id: str):
    """
    Read an existing payment session
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/payments/v1/sessions/{session_id}',
    description=""" Use this API call to update a Klarna Payments session with new details, in case something in the order has changed and the checkout has been reloaded. Including if the consumer adds a new item to the cart or if consumer details are updated.
Read more on **[Update an existing payment session](https://docs.klarna.com/klarna-payments/other-actions/update-the-cart/)**. """,
    tags=['payment_session_operations'],
)
def update_credit_session(session_id: str, body: Session = ...):
    """
    Update an existing payment session
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
